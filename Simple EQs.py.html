#!/usr/bin/env python
# coding: utf-8

# In[2]:


# This is us playing with simplified equations to determine the behavior of V*/B*

import numpy as np

import matplotlib as mpl
import matplotlib.pyplot as plt
import matplotlib.colors as colors
from matplotlib import cm
import matplotlib.tri as tri
from matplotlib.colors import LogNorm
import matplotlib.patches as mpatches
from matplotlib.ticker import LogFormatter 

from collections import Counter

from functools import wraps

import csv
import sys

import itertools
from itertools import islice, cycle, chain

import scipy as sp
from scipy.interpolate import griddata
from scipy import interpolate
from scipy.integrate import odeint
from scipy.stats import pareto
from scipy.stats import loguniform

import seaborn as sns
import pandas as pd

import statistics as stats
import lhsmdu

from math import nan

from SALib.sample import saltelli, latin, ff
from SALib.analyze import sobol

import random


# In[115]:


from scipy.stats import ks_2samp

runs = 50

dfEric = pd.read_excel("ICEVBR_18Aug.xls")

Eric_VBR = dfEric.Virus/dfEric.Bacteria
RangelistB = []
RangelistM = []
RangelistD = []
RangelistBAvg = []
RangelistMAvg = []
RangelistDAvg = []

# in each run, we want to change the endpoints of the parameter distributions simultaneously
i = 0
j = 0



# the while loop is set to run until we find X sets of parameters that produce a distribution of 
# simulated VBRs which matches the distribution of real data with 95% acceptance rate

while i < runs:
    # we want to include a step than randomly creates a range of values, since we're looking not for an indivudal 
    # value but instead looking for the right *range* of values.
    betalo = np.random.uniform(1,1000)
    betahi =  np.random.uniform(betalo,1000)
    mulo = np.random.uniform(-15,0)
    muhi = np.random.uniform(mulo,0)
    deltalo = np.random.uniform(-15,0)
    deltahi = np.random.uniform(deltalo,0)




    # after we get a random range of values, we want to sample within that range of values to produce
    # a representative stretch of values to test if they actually reproduce the VBR.
    problem = {
        "num_vars" : 3,
        "names" : ['beta', 'mu', 'm'],
        "bounds": [[betalo, betahi], 
                   [mulo, muhi], 
                   [deltalo, deltahi]],
        "dists":['unif','unif','unif']
    }

    param_values = saltelli.sample(problem,100,calc_second_order=True)
    

    # scale the parameters properly
    
    beta = param_values[:,0]
    mu = 10**param_values[:,1]
    delta = 10**param_values[:,2]

    # simulate VBR
    simVBR = ((mu)*(beta - 1))/(delta)

    # test the simulated VBRS against the real data
    result = ks_2samp(Eric_VBR, simVBR)
    if result[1] > 0.05:
        print('beta range is:', betalo, ',', betahi)        
        print('mu range is:', 10**(mulo), ',', 10**(muhi))
        print('delta range is:', 10**(deltalo), ',', 10**(deltahi), '\n')
        
        i += 1
        
        RangelistB.append([betalo, betahi])
        RangelistBAvg.append((betalo + betahi)/2)
        RangelistM.append([mulo, muhi])
        RangelistMAvg.append((mulo + muhi)/2)
        RangelistD.append([deltalo, deltahi])
        RangelistDAvg.append((deltalo + deltahi)/2)

    j += 1
    
print ('finished, total runs is:', j)
print ('ratio is:', i/j)


# In[154]:


# lets plot all the ranges as a set of ordered lines
#from itertools import izip

yax = []
yax1 = []
    
for i in range(1,runs+1):
    yax.append([i,i])
    yax1.append(i)
    
sorted_lists = sorted(zip(RangelistB, RangelistM, RangelistD,RangelistMAvg, RangelistDAvg, RangelistBAvg ), reverse = True, key=lambda x: x[4])
RangelistB2, RangelistM2, RangelistD2, RangelistMAvg2, RangelistDAvg2,RangelistBAvg2 = [[x[i] for x in sorted_lists] for i in range(6)]


# And plot
plt.rcParams["font.family"] = "sans-serif"
plt.rcParams.update({'font.size': 20})
#fig, axs = plt.subplots(1,2,figsize=(15,15))
fig = plt.figure(figsize=(20,5))
fig.tight_layout()
cm = plt.get_cmap('viridis')
#fig = plt.figure()
colorlist = [cm(1.*i/runs) for i in range(runs)]


#fig, (ax1, ax2, ax3) = plt.subplots(1,3, figsize=(15, 6), facecolor='w', edgecolor='k')



ax = fig.add_subplot(131)
for i in range(runs):
    plt.plot(RangelistB2[i],yax[i], color = colorlist[i])
    plt.plot(RangelistBAvg2[i],yax1[i],color = colorlist[i], marker = 'o', markeredgecolor= 'k')
    plt.title('Burst Size')
    plt.xlabel('Burst Size')
    ax.set_yticklabels("")
    
ax1 = fig.add_subplot(132)
for i in range(runs):
    plt.plot(RangelistM2[i],yax[i], color = colorlist[i])
    plt.plot(RangelistMAvg2[i],yax1[i],color = colorlist[i], marker = 'o', markeredgecolor= 'k')
    plt.title('Growth Rate')
    plt.xlabel('Growth Rate Range (log 10)')
    ax1.set_yticklabels("")
    
ax3 = fig.add_subplot(133)
for i in range(runs):
    plt.plot(RangelistD2[i],yax[i], color = colorlist[i])
    plt.plot(RangelistDAvg2[i],yax1[i],color = colorlist[i], marker = 'o', markeredgecolor= 'k')
    plt.title('Decay Rate')
    plt.xlabel('Decay Rate Range (log 10)')
    ax3.set_yticklabels("")
    
    


# In[175]:


fig.savefig('ParameterDistribution.png', dpi=300)


# In[116]:


(RangelistB50, RangelistM50, RangelistD50, RangelistMavg50, RangelistDAvg50, RangelistBAvg50) = (RangelistB, RangelistM, RangelistD, RangelistMavg, RangelistDAvg, RangelistBAvg)


# In[13]:


fig2 = plt.figure(figsize=(15,4))



plt.subplot(1, 3, 1)
plt.hist(param_values[:,0], bins = 50, color = "orange", ec="white")
plt.ylabel('Frequency')
plt.xlabel('burst (beta)')



plt.subplot(1, 3, 2)
plt.hist((10**param_values[:,1]),bins=np.logspace(np.log10(1e-3),np.log10(1e-1), 50), color = "orange", ec="white")

plt.xscale('log')
plt.xlabel('growth (mu)')


plt.subplot(1, 3, 3)
plt.hist((10**param_values[:,2]),bins=np.logspace(np.log10(1e-4),np.log10(1e-1), 50), color = "orange", ec="white")
plt.xscale('log')
plt.xlabel('decay (m)')

fig1.suptitle('Parameter sampling distributions')


# In[7]:


fig2.savefig('8Oct_SimpleEQSamples.png', dpi=600)


# In[26]:


import matplotlib.pyplot as plt
import numpy as np; np.random.seed(10)
import seaborn as sns
import seaborn.distributions as sd
from seaborn.palettes import color_palette, blend_palette
from six import string_types

dfEric = pd.read_excel("ICEVBR_18Aug.xls")
dfEricSW = pd.read_excel("SWVBR_18Aug.xls")


fig1 = plt.figure(figsize=(30,30))
fig1.tight_layout()
plt.rcParams.update({'font.size': 10})

def _bivariate_kdeplot(x, y, filled, fill_lowest,
                       kernel, bw, gridsize, cut, clip,
                       axlabel, cbar, cbar_ax, cbar_kws, ax, **kwargs):
    """Plot a joint KDE estimate as a bivariate contour plot."""
    # Determine the clipping
    if clip is None:
        clip = [(-np.inf, np.inf), (-np.inf, np.inf)]
    elif np.ndim(clip) == 1:
        clip = [clip, clip]

    # Calculate the KDE
    if sd._has_statsmodels:
        xx, yy, z = sd._statsmodels_bivariate_kde(x, y, bw, gridsize, cut, clip)
    else:
        xx, yy, z = sd._scipy_bivariate_kde(x, y, bw, gridsize, cut, clip)

    # Plot the contours
    n_levels = kwargs.pop("n_levels", 10)
    cmap = kwargs.get("cmap", "BuGn" if filled else "BuGn_d")
    if isinstance(cmap, string_types):
        if cmap.endswith("_d"):
            pal = ["#333333"]
            pal.extend(color_palette(cmap.replace("_d", "_r"), 2))
            cmap = blend_palette(pal, as_cmap=True)
        else:
            cmap = plt.cm.get_cmap(cmap)

    kwargs["cmap"] = cmap
    contour_func = ax.contourf if filled else ax.contour
    cset = contour_func(xx, yy, z, n_levels, **kwargs)
    if filled and not fill_lowest:
        cset.collections[0].set_alpha(0)
    kwargs["n_levels"] = n_levels

    if cbar:
        cbar_kws = {} if cbar_kws is None else cbar_kws
        ax.figure.colorbar(cset, cbar_ax, ax, **cbar_kws)

    # Label the axes
    if hasattr(x, "name") and axlabel:
        ax.set_xlabel(x.name)
    if hasattr(y, "name") and axlabel:
        ax.set_ylabel(y.name)

    return ax, cset

# monkey patching
sd._bivariate_kdeplot = _bivariate_kdeplot

#plot
fig1, ax = plt.subplots()
"""ax.set_yscale('log')
ax.set_xscale('log')"""

ax.set_ylim(5,10)
ax.set_xlim(4,9)

ax.set_ylabel('Virus concentration, log10 transformed')
ax.set_xlabel('Bacterial concentration, log10 transformed')
_, cs = sns.kdeplot(np.log10(dfEric["Bacteria"]), np.log10(dfEric["Virus"]), ax=ax, cmap="Blues", shade=True, shade_lowest=False)
#_, cs2 = sns.kdeplot(np.log10(dfEricSW["Bacteria"]), np.log10(dfEricSW["Virus"]), ax=ax, cmap="Blues", shade=True, shade_lowest=False)
#_, cs = sns.kdeplot((dfEric["Bacteria"]), (dfEric["Virus"]), ax=ax, cmap="OrRd", shade=True, shade_lowest=False)
#_, cs2 = sns.kdeplot((dfEricSW["Bacteria"]), (dfEricSW["Virus"]), ax=ax, cmap="Blues", shade=True, shade_lowest=False)
# label the contours
# add a colorbar
#fig1.colorbar(cs)

Bact1 = (1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10)
VBR_01 = (1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8,)
VBR_1 = (1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9)
VBR1 = (1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10)
VBR10 = (1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11)
VBR100 = (1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12)
VBR1000 = (1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13)
VBR10000 = (1e8, 1e9, 1e10, 1e11,1e12, 1e13, 1e14)
VBR100000 = (1e9, 1e10, 1e11, 1e12, 1e13, 1e14, 1e15)

"""plt.plot(np.log10(Bact1), np.log10(VBR_01), 'k:')
plt.plot(np.log10(Bact1), np.log10(VBR_1), 'k:')"""
plt.plot(np.log10(Bact1), np.log10(VBR1), 'k:', alpha = 0.25)
plt.plot(np.log10(Bact1), np.log10(VBR10), 'k:', alpha = 0.25)
plt.plot(np.log10(Bact1), np.log10(VBR100),'k:', alpha = 0.25)
plt.plot(np.log10(Bact1), np.log10(VBR1000), 'k:', alpha = 0.25)
plt.plot(np.log10(Bact1), np.log10(VBR10000), 'k:',alpha = 0.25 )
"""plt.plot(np.log10(Bact1), np.log10(VBR100000), 'k:')
"""

plt.plot





#plt.scatter(np.log10(dfEric["Bacteria"]), np.log10(dfEric["Virus"]))
#plt.scatter(np.log10(dfEricSW["Bacteria"]), np.log10(dfEricSW["Virus"]))
plt.show()


# In[27]:


fig1.savefig('29Oct_VBR_seaice.png', dpi=600)


# In[9]:


dfEric = pd.read_excel("ICEVBR_18Aug.xls")

Eric_VBR = dfEric.Virus/dfEric.Bacteria
print (Eric_VBR)


# In[16]:


import numpy as np
import matplotlib.pyplot as plt


fig1, axs = plt.subplots(3,3,figsize=(15,15))
x = np.random.uniform(low=0.5, high=1.5, size=((400)))
x1 = np.random.uniform(low=0.5, high=0.9, size=((400)))
x2 = np.random.uniform(low= 1.1, high=1.5, size=((400)))



dfEric = pd.read_excel("ICEVBR_18Aug.xls")

Eric_VBR = dfEric.Virus/dfEric.Bacteria

from SALib.sample import saltelli, latin, ff
from SALib.analyze import sobol

problem = {
    "num_vars" : 3,
    "names" : ['beta', 'mu', 'm'],
    "bounds": [[1, 500], 
               [-5, -1], 
               [-6,-1]],
    "dists":['unif','unif','unif']
}
 
param_values = saltelli.sample(problem,50,calc_second_order=True)

font = {'family': 'sansserif',
        'color':  'k',
        'weight': 'normal',
        'size': 10,
        }

# mu variable
mu = 10**param_values[:,1]
beta = 100
delta = 1e-6
VBR_mu = ((mu)*(beta - 1))/(delta)


axs[0,0].scatter(x, VBR_mu, c = mu, cmap = 'Purples', s=25, alpha = 0.6)
mean = VBR_mu.mean()
axs[0,0].text(1.55, mean, 'mean', fontdict=font)
axs[0,0].plot([0.5,1.5],[mean,mean], color="k")
#axs[0,0].set_yscale('log')
#labels = [item.get_text() for item in axs.get_xticklabels()]
axs[0,0].set_title('Varied Mu')

#beta change
# beta variable
mu = 0.01
beta = param_values[:,0]
delta = 1e-6
VBR_beta = ((mu)*(beta - 1))/(delta)

value = VBR_beta
value_key = beta
axs[0,1].scatter(x, value, c = value_key, cmap = 'Blues', s=25, alpha = 0.6)
mean = value.mean()
axs[0,1].text(1.55, mean, 'mean', fontdict=font)
axs[0,1].plot([0.5,1.5],[mean,mean], color="k")
#axs[0,0].set_yscale('log')
labels = [item.get_text() for item in ax.get_xticklabels()]
axs[0,1].set_title('Varied Beta')

# delta variable
mu = 0.01
beta = 100
delta = 10**param_values[:,2]
VBR_delta = ((mu)*(beta - 1))/(delta)

value = VBR_delta
value_key = delta
axs[0,2].scatter(x, value, c = value_key, cmap = 'Greens', s=25, alpha = 0.6)
mean = value.mean()
axs[0,2].text(1.55, mean, 'mean', fontdict=font)
axs[0,2].plot([0.5,1.5],[mean,mean], color="k")
#axs[0,0].set_yscale('log')
labels = [item.get_text() for item in ax.get_xticklabels()]
axs[0,2].set_title('Varied Delta')


# mu and beta variable
mu = 10**param_values[:,1]
beta = param_values[:,0]
delta = 1e-6
value_key1 = mu*beta
VBR_mb = ((mu)*(beta - 1))/(delta)


value = VBR_mb
value_key = delta
axs[1,0].scatter(x1, value, c = mu, cmap = 'Purples', s=25, alpha = 0.6)
axs[1,0].scatter(x2, value, c = beta, cmap = 'Blues', s=25, alpha = 0.6)
mean = value.mean()
axs[1,0].text(1.55, mean, 'mean', fontdict=font)
axs[1,0].plot([0.5,1.5],[mean,mean], color="k")
#axs[0,0].set_yscale('log')
labels = [item.get_text() for item in ax.get_xticklabels()]
axs[1,0].set_title('Co-varied Mu and Beta')

# beta and delta variable
mu = 0.01
beta = param_values[:,0]
delta = 10**param_values[:,2]
value_key1 = beta*delta
VBR_bd = ((mu)*(beta - 1))/(delta)


value = VBR_bd
axs[1,1].scatter(x1, value, c = beta, cmap = 'Blues', s=25, alpha = 0.6)
axs[1,1].scatter(x2, value, c = delta, cmap = 'Greens', s=25, alpha = 0.6)
mean = value.mean()
axs[1,1].text(1.55, mean, 'mean', fontdict=font)
axs[1,1].plot([0.5,1.5],[mean,mean], color="k")
#axs[0,0].set_yscale('log')
labels = [item.get_text() for item in ax.get_xticklabels()]
axs[1,1].set_title('Co-varied Beta and Delta')

# mu and delta variable
mu = 10**param_values[:,1]
beta = 100
delta = 10**param_values[:,2]
value_key1 = mu*delta
VBR_md = ((mu)*(beta - 1))/(delta)

value = VBR_md
axs[2,0].scatter(x1, value, c = mu, cmap = 'Purples', s=25, alpha = 0.6)
axs[2,0].scatter(x2, value, c = delta, cmap = 'Greens', s=25, alpha = 0.6)
mean = value.mean()
axs[2,0].text(1.55, mean, 'mean', fontdict=font)
axs[2,0].plot([0.5,1.5],[mean,mean], color="k")
#axs[0,0].set_yscale('log')
labels = [item.get_text() for item in ax.get_xticklabels()]
axs[2,0].set_title('Co-varied Mu and Delta')

# mu and beta and delta variable
mu = 10**param_values[:,1]
beta = param_values[:,0]
delta = 10**param_values[:,2]
value_key1 = mu*delta*beta
VBR_mbd = ((mu)*(beta - 1))/(delta)

value = VBR_mbd
x3 = np.random.uniform(low=0.5, high=0.8, size=((400)))
x4 = np.random.uniform(low=0.85, high=1.15, size=((400)))
x5 = np.random.uniform(low= 1.2, high=1.5, size=((400)))
axs[2,2].scatter(x3, value, c = mu, cmap = 'Purples', s=25, alpha = 0.6)
axs[2,2].scatter(x4, value, c = beta, cmap = 'Blues', s=25, alpha = 0.6)
axs[2,2].scatter(x5, value, c = delta, cmap = 'Greens', s=25, alpha = 0.6)
mean = value.mean()
axs[2,2].text(1.55, mean, 'mean', fontdict=font)
axs[2,2].plot([0.5,1.5],[mean,mean], color="k")
#axs[0,0].set_yscale('log')
#labels = [item.get_text() for item in ax.get_xticklabels()]
axs[2,2].set_title('Co-varied Mu, Beta, and Delta')


# Add Ratio Lines
index1 = [0,1,2]
index2 = [0,1,2]


font2 = {'family': 'sansserif',
        'color':  'gray',
        'weight': 'normal',
        'size': 10,
        }

for i in index1:
    for j in index2:
        axs[i,j].plot([0.5,1.5],[1,1], color="gray", alpha = 0.5)
        axs[i,j].plot([0.5,1.5],[10,10], color="gray", alpha = 0.5)
        axs[i,j].plot([0.5,1.5],[100,100], color="gray", alpha = 0.5)
        axs[i,j].plot([0.5,1.5],[1000,1000], color="gray", alpha = 0.5)
        axs[i,j].plot([0.5,1.5],[10000,10000], color="gray", alpha = 0.5)
        axs[i,j].set_xlim(0,2)
        #axs[i,j].set_ylim(0,1e8)
        axs[i,j].set_yscale('log')
        empty_string_labels = ['']*len(labels)
        axs[i,j].set_xticklabels(empty_string_labels)
        axs[i,j].text(1.55, 1, '1', fontdict=font2)
        axs[i,j].text(1.55, 10, '10', fontdict=font2)
        axs[i,j].text(1.55, 100, '100', fontdict=font2)
        axs[i,j].text(1.55, 1000, '1000', fontdict=font2)
        axs[i,j].text(1.55, 10000, '10000', fontdict=font2)
        axs[i,j].set_ylabel('Simulated VBR')
        axs[i,j].boxplot(Eric_VBR)




#formatting all subplots
fig1.delaxes(axs[1][2])
fig1.delaxes(axs[2][1])
#fig1.delaxes(axs[2][2])
#fig1.delaxes(axs[3][1])
#fig1.delaxes(axs[3][2])

plt.show()


# In[10]:



# fake up some data

fig1, ax1 = plt.subplots()
ax1.set_title('Basic Plot')
ax1.boxplot(Eric_VBR)


# In[ ]:




