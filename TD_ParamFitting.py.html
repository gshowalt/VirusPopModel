#!/usr/bin/env python
# coding: utf-8

# In[1]:


# importing all modules
import numpy as np

import matplotlib as mpl
import matplotlib.pyplot as plt
import matplotlib.colors as colors
from matplotlib import cm
import matplotlib.tri as tri
from matplotlib.colors import LogNorm
import matplotlib.patches as mpatches
from matplotlib.ticker import LogFormatter 
from labellines import labelLine, labelLines
from collections import Counter

from functools import wraps

import csv
import sys

import itertools
from itertools import islice, cycle, chain

import scipy as sp
from scipy.interpolate import griddata
from scipy import interpolate
from scipy.integrate import odeint
from scipy.stats import pareto
from scipy.stats import loguniform

import seaborn as sns
import pandas as pd

import statistics as stats
import lhsmdu

from math import nan

from SALib.sample import saltelli, latin, ff
from SALib.analyze import sobol

import random


# In[24]:


# define the function which includes the differential equations


def f2(s,t, temp, beta, mu, phi, delta):
    
    # first define the relative contact rate (RCR) and brine concentrating factor (BCF) by temp
    if temp < -1:
        RCR = 0.0716*temp**4 + 2.9311*temp**3 + 34.108*temp**2 + 45.826*temp + 3.5125 #Fit from Wells and Deming, 2006
        BCF = -0.0106 * temp **2 - 0.519 * temp + 0.2977
        sal = 32 * BCF
    else:
        RCR = 1
        sal = 32
  
    
    # scale adsorption rate by RCR to incorporate the sea ice 
    phi = phi * RCR    

    
    # SET PARAMETERS
    alpha = (1.2e-7)*3**((temp-23)/10)#4.2e-7 at +8, or 1.2e-7 at lower temps, at -5 --> mu = 0.25/day = 0.01/hr = 1e-8
    # alpha is a coefficient that we'd like to change with temperature? Or change eta?
    #nutrient transfer coefficient to bacteria (ug/cell * hr)
    Q = 0.022
    #half saturation constant (ug/mL)
    d = 1e-8
    #constant of bacterial death (1/hr)
    
    # leak, lyse efficiencies here:
    g = 0.2
    n = 0.99
    
    
    #gamma is a lysogeny value
    gamma = 1 #-1/temp #*mu
    
    # set up solution matrix
    N = s[0]
    B = s[1]
    V = s[2]
  
    #systems of equations below
  
    dNdt = - alpha * (N / (N + Q)) * B + g * (alpha  * (N/(N+Q))*B) + (n * 1e-7 * (gamma) * phi * V * B) 
    if N < 0:
        N = 0
    dBdt = (mu) * (N/(Q + N)) * B - gamma * phi * V * B - d*B
    if B < 1:
        B = 1
    dVdt =  gamma*beta * B * phi*V - phi * V * B -  delta*V
    if V < 1:
        V = 1
   
    #print (mu, beta, phi, gamma)
    return [dNdt, dBdt, dVdt]


# In[13]:





# In[55]:


from scipy.stats import ks_2samp


# define time, temperature scale
time = 5000
temp_list = np.linspace(-10, -1, 8)
t = np.linspace(1,time,1000)

# define runs, values for observed data
runs = 100

dfEric = pd.read_excel("ICEVBR_18Aug.xls")

Eric_VBR = dfEric.Virus/dfEric.Bacteria
RangelistB = []
RangelistM = []
RangelistD = []
RangelistP = []
RangelistBAvg = []
RangelistMAvg = []
RangelistDAvg = []
RangelistPAvg = []
simVBR  = []

# in each run, we want to change the endpoints of the parameter distributions simultaneously
i = 0
j = 0



# the while loop is set to run until we find X sets of parameters that produce a distribution of 
# simulated VBRs which matches the distribution of real data with 95% acceptance rate

while i < runs:
    # we want to include a step than randomly creates a range of values, since we're looking not for an indivudal 
    # value but instead looking for the right *range* of values.
    betalo = np.random.uniform(1,1000)
    betahi =  np.random.uniform(betalo,1000)
    mulo = np.random.uniform(-15,0)
    muhi = np.random.uniform(mulo,0)
    deltalo = np.random.uniform(-15,0)
    deltahi = np.random.uniform(deltalo,0)
    philo = np.random.uniform(-15,-5)
    phihi = np.random.uniform(philo,-5)



    # after we get a random range of values, we want to sample within that range of values to produce
    # a representative stretch of values to test if they actually reproduce the VBR.
    problem = {
        "num_vars" : 4,
        "names" : ['beta', 'mu', 'm', 'phi'],
        "bounds": [[betalo, betahi], 
                   [mulo, muhi], 
                   [deltalo, deltahi],
                   [philo, phihi]],
        "dists":['unif','unif','unif', 'unif']
    }

    param_values = saltelli.sample(problem,100,calc_second_order=True)
    

    # scale the parameters properly
    
    beta = param_values[:,0]
    mu = 10**param_values[:,1]
    delta = 10**param_values[:,2]
    phi = 10**param_values[:,3]

    # establish constant parameters
    alpha = (1.2e-7)*3**((-5-23)/10)#4.2e-7 at +8, or 1.2e-7 at lower temps, at -5 --> mu = 0.25/day = 0.01/hr = 1e-8
    #nutrient transfer coefficient to bacteria (ug/cell * hr)
    Q = 0.022
    #half saturation constant (ug/mL)
    d = 1e-8
    #constant of bacterial death (1/hr)
    
    # leak, lyse efficiencies here:
    g = 0.2
    n = 0.99
    
    
    # simulate VBRs
    simN = (n*1e-7*d*Q)/((alpha)*(g-1) + (n*1e-7)*(mu-d))
    simB = delta / (phi * (beta - 1))
    simV = ((mu*simN)/(simN + Q) - d)/(gamma * phi)
    
    simVBR = simV/simB
    
        # test the simulated VBRS against the real data
    result = ks_2samp(Eric_VBR, simVBR)
    if result[1] > 0.05:
        print('beta range is:', betalo, ',', betahi)        
        print('mu range is:', 10**(mulo), ',', 10**(muhi))
        print('delta range is:', 10**(deltalo), ',', 10**(deltahi), '\n')
        print('phi range is:', 10**(philo), ',', 10**(phihi), '\n')
        
        i += 1
        
        RangelistB.append([betalo, betahi])
        RangelistBAvg.append((betalo + betahi)/2)
        RangelistM.append([mulo, muhi])
        RangelistMAvg.append((mulo + muhi)/2)
        RangelistD.append([deltalo, deltahi])
        RangelistDAvg.append((deltalo + deltahi)/2)
        RangelistP.append([philo, phihi])
        RangelistPAvg.append((philo + phihi)/2)
    j += 1
    
print ('finished, total runs is:', j)
print ('ratio is:', i/j)


# In[56]:


print(i)


# In[57]:


print(j)


# In[61]:


# lets plot all the ranges as a set of ordered lines
#from itertools import izip

yax = []
yax1 = []
runs = 46
    
for i in range(1,runs+1):
    yax.append([i,i])
    yax1.append(i)
    
sorted_lists = sorted(zip(RangelistB, RangelistM, RangelistD, RangelistP, RangelistMAvg, RangelistDAvg, RangelistPAvg, RangelistBAvg ), reverse = True, key=lambda x: x[6])
RangelistB2, RangelistM2, RangelistD2, RangelistP2, RangelistMAvg2, RangelistDAvg2, RangelistPAvg2, RangelistBAvg2 = [[x[i] for x in sorted_lists] for i in range(8)]


# And plot
plt.rcParams["font.family"] = "sans-serif"
plt.rcParams.update({'font.size': 12.5})
#fig, axs = plt.subplots(1,2,figsize=(15,15))
fig = plt.figure(figsize=(20,5))
fig.tight_layout()
cm = plt.get_cmap('viridis')
#fig = plt.figure()
colorlist = [cm(1.*i/runs) for i in range(runs)]


#fig, (ax1, ax2, ax3) = plt.subplots(1,3, figsize=(15, 6), facecolor='w', edgecolor='k')



ax = fig.add_subplot(141)
for i in range(runs):
    plt.plot(RangelistB2[i],yax[i], color = colorlist[i])
    plt.plot(RangelistBAvg2[i],yax1[i],color = colorlist[i], marker = 'o', markeredgecolor= 'k')
    plt.title('Burst Size')
    plt.xlabel('Burst Size')
    ax.set_yticklabels("")
    
ax1 = fig.add_subplot(142)
for i in range(runs):
    plt.plot(RangelistM2[i],yax[i], color = colorlist[i])
    plt.plot(RangelistMAvg2[i],yax1[i],color = colorlist[i], marker = 'o', markeredgecolor= 'k')
    plt.title('Growth Rate')
    plt.xlabel('Growth Rate Range (log 10)')
    ax1.set_yticklabels("")
    
ax2 = fig.add_subplot(143)
for i in range(runs):
    plt.plot(RangelistD2[i],yax[i], color = colorlist[i])
    plt.plot(RangelistDAvg2[i],yax1[i],color = colorlist[i], marker = 'o', markeredgecolor= 'k')
    plt.title('Decay Rate')
    plt.xlabel('Decay Rate Range (log 10)')
    ax2.set_yticklabels("")
    
ax3 = fig.add_subplot(144)
for i in range(runs):
    plt.plot(RangelistP2[i],yax[i], color = colorlist[i])
    plt.plot(RangelistPAvg2[i],yax1[i],color = colorlist[i], marker = 'o', markeredgecolor= 'k')
    plt.title('Adsorption Rate')
    plt.xlabel('Adsorp. Rate Range (log 10)')
    ax3.set_yticklabels("")

fig.suptitle('Full model parameter fitting')


# In[60]:


fig.savefig('TimeDependent_ParamFit_46.png', dpi=300)


# In[83]:


RangelistB3 = np.array(RangelistB2)
RangelistM3 = np.array(RangelistM2)
RangelistD3 = np.array(RangelistD2)
RangelistP3 = np.array(RangelistP2)
print (RangelistB3[:,0])


# In[88]:


from pandas import DataFrame
df = DataFrame({'Beta Low': RangelistB3[:,0], 'Beta Hi': RangelistB3[:,1], 'Mu Low': RangelistM3[:,0], 'Mu Hi': RangelistM3[:,1], 'Delta Low': RangelistD3[:,0], 'Delta Hi': RangelistD3[:,1], 'Phi Low': RangelistP3[:,0], 'Phi Hi': RangelistP3[:,1]})

print (df)

df.to_excel('TDParams_runs46.xlsx', sheet_name='sheet1', index=False)


# In[ ]:


"""from scipy.stats import ks_2samp


# define time, temperature scale
time = 5000
temp_list = np.linspace(-10, -1, 8)
t = np.linspace(1,time,1000)

# define runs, values for observed data
runs = 2

dfEric = pd.read_excel("ICEVBR_18Aug.xls")

Eric_VBR = dfEric.Virus/dfEric.Bacteria
RangelistB = []
RangelistM = []
RangelistD = []
RangelistBAvg = []
RangelistMAvg = []
RangelistDAvg = []
simVBR  = []

# in each run, we want to change the endpoints of the parameter distributions simultaneously
i = 0
j = 0



# the while loop is set to run until we find X sets of parameters that produce a distribution of 
# simulated VBRs which matches the distribution of real data with 95% acceptance rate

while i < runs:
    # we want to include a step than randomly creates a range of values, since we're looking not for an indivudal 
    # value but instead looking for the right *range* of values.
    betalo = np.random.uniform(1,1000)
    betahi =  np.random.uniform(betalo,1000)
    mulo = np.random.uniform(-15,0)
    muhi = np.random.uniform(mulo,0)
    deltalo = np.random.uniform(-15,0)
    deltahi = np.random.uniform(deltalo,0)
    philo = np.random.uniform(-15,-1)
    phihi = np.random.uniform(philo,-1)



    # after we get a random range of values, we want to sample within that range of values to produce
    # a representative stretch of values to test if they actually reproduce the VBR.
    problem = {
        "num_vars" : 4,
        "names" : ['beta', 'mu', 'm', 'phi'],
        "bounds": [[betalo, betahi], 
                   [mulo, muhi], 
                   [deltalo, deltahi],
                   [philo, phihi]],
        "dists":['unif','unif','unif', 'unif']
    }

    param_values = saltelli.sample(problem,100,calc_second_order=True)
    

    # scale the parameters properly
    
    beta = param_values[:,0]
    mu = 10**param_values[:,1]
    delta = 10**param_values[:,2]
    phi = 10**param_values[:,3]

    # simulate VBRs
    
    for temp in temp_list:
        if temp < -1:
            RCR = 0.0716*temp**4 + 2.9311*temp**3 + 34.108*temp**2 + 45.826*temp + 3.5125 #Fit from Wells and Deming, 2006
            BCF = -0.0106*temp**2 - 0.519*temp + 0.2977
            sal = 32 * BCF
        else:
            BCF = 1
            sal = 32

        nuts_init = 0.12 * BCF
        bact_init = 1e4 * BCF
        vir_init = 1e5 * BCF
        
        s0 = [nuts_init, bact_init, vir_init]
        for i in range(0,len(beta)):
            solx = odeint(f2, s0, t, args = (temp, beta[i], mu[i], phi[i], delta[i]))

            nuts = solx[:,0]
            bact = solx[:,1]
            virus = solx[:,2]
            
            for x in virus:
                if x <=0:
                    x = 1

            simVBR.append(virus/bact)    

    
    simVBR = list(simVBR)
    print (simVBR)
    # test the simulated VBRS against the real data
    result = ks_2samp(Eric_VBR, simVBR)
    if result[1] > 0.05:
        print('beta range is:', betalo, ',', betahi)        
        print('mu range is:', 10**(mulo), ',', 10**(muhi))
        print('delta range is:', 10**(deltalo), ',', 10**(deltahi), '\n')
        
        i += 1
        
        RangelistB.append([betalo, betahi])
        RangelistBAvg.append((betalo + betahi)/2)
        RangelistM.append([mulo, muhi])
        RangelistMAvg.append((mulo + muhi)/2)
        RangelistD.append([deltalo, deltahi])
        RangelistDAvg.append((deltalo + deltahi)/2)

    j += 1
    
print ('finished, total runs is:', j)
print ('ratio is:', i/j)"""

